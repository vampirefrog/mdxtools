#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdint.h>

#include "vgm_logger.h"

// This is a hardcoded header just for X68000 logs, with YM2151 at 4MHz and M6258 at 8MHz
// which makes this class non-reusable outside of this project, which is fine
uint8_t vgm_header[] = {
	0x56,0x67,0x6d,0x20, 0x00,0x00,0x00,0x00, 0x61,0x01,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x09,0x3d,0x00, 0x8c,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x12,0x7a,0x00, 0x06,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
};

int vgm_logger_init(struct vgm_logger *log, const char *filename) {
	log->total_samples = 0;
	log->total_bytes = 0;
	log->wait_cummulative = 0;
	log->f = fopen(filename, "wb");
	if(!log->f) {
		fprintf(stderr, "Could not open %s for writing: %s (%d)\n", filename, strerror(errno), errno);
		return -1;
	}
	fwrite(vgm_header, 1, sizeof(vgm_header), log->f);

	return 0;
}

int vgm_logger_write_wait(struct vgm_logger *log, int wait) {
	log->wait_cummulative += wait;
	return log->wait_cummulative;
}

static void vgm_logger_write_wait_cmd(struct vgm_logger *log) {
	if(log->wait_cummulative == 0) return;

	log->total_samples += log->wait_cummulative;

	uint8_t buf[4];

	while(log->wait_cummulative > 65535) {
		buf[0] = 0x61;
		buf[1] = 0xff;
		buf[2] = 0xff;
		log->total_bytes += fwrite(buf, 1, 3, log->f);
		log->wait_cummulative -= 65535;
	}

	if(log->wait_cummulative == 0) return;

	if(log->wait_cummulative == 735) {
		buf[0] = 0x62;
		log->total_bytes += fwrite(buf, 1, 1, log->f);
	} else if(log->wait_cummulative == 882) {
		buf[0] = 0x63;
		log->total_bytes += fwrite(buf, 1, 1, log->f);
	} else if(log->wait_cummulative <= 16) {
		buf[0] = 0x70 + log->wait_cummulative - 1;
		log->total_bytes += fwrite(buf, 1, 1, log->f);
	} else {
		buf[0] = 0x61;
		buf[1] = log->wait_cummulative & 0xff;
		buf[2] = log->wait_cummulative >> 8;
		log->total_bytes += fwrite(buf, 1, 3, log->f);
	}

	log->wait_cummulative = 0;
}

int vgm_logger_write_ym2151(struct vgm_logger *log, uint8_t reg, uint8_t val) {
	vgm_logger_write_wait_cmd(log);
	uint8_t buf[3] = { 0x54, reg, val };
	return log->total_bytes += fwrite(buf, 1, sizeof(buf), log->f);
}

int vgm_logger_write_okim6258(struct vgm_logger *log, uint8_t port, uint8_t val) {
	vgm_logger_write_wait_cmd(log);
	uint8_t buf[3] = { 0xb7, port, val };
	return log->total_bytes += fwrite(buf, 1, sizeof(buf), log->f);
}

static int vgm_logger_write_eof(struct vgm_logger *log) {
	uint8_t eof[] = { 0x66 };
	return log->total_bytes += fwrite(eof, 1, sizeof(eof), log->f);
}

int vgm_logger_end(struct vgm_logger *log) {
	vgm_logger_write_wait_cmd(log);
	vgm_logger_write_eof(log);
	fseek(log->f, 0x04, SEEK_SET);
	uint32_t i = sizeof(vgm_header) + log->total_bytes - 4;
	fwrite(&i, 1, sizeof(i), log->f);
	fseek(log->f, 0x18, SEEK_SET);
	i = log->total_samples;
	fwrite(&i, 1, sizeof(i), log->f);
	return fclose(log->f);
}
